<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris Game</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <canvas id="tetrisCanvas" width="300" height="600"></canvas>
  <script src="script.js"></script>
</body>

</html>


canvas {
  border: 1px solid black;
  display: block;
  margin: 0 auto;
}// 方块形状定义，用二维数组表示，0表示空白，1表示方块所在位置
const SHAPES = [
  [
    [0, 0, 0],
    [1, 1, 0],
    [0, 1, 1]
  ],
  [
    [0, 0, 0],
    [0, 1, 1],
    [1, 1, 0]
  ],
  [
    [0, 0, 0, 0],
    [1, 1, 1, 1],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
  ],
  [
    [0, 0, 0],
    [1, 1, 0],
    [1, 1, 0]
  ],
  [
    [0, 0, 0],
    [1, 0, 0],
    [1, 1, 1]
  ],
  [
    [0, 0, 0],
    [0, 0, 1],
    [1, 1, 1]
  ],
  [
    [0, 0, 0],
    [0, 1, 0],
    [1, 1, 1]
  ]
];

// 对应方块形状的颜色
const COLORS = ["green", "red", "blue", "orange", "yellow", "purple", "cyan"];

// 游戏区域的宽度和高度（以方块格子数量计）
const WIDTH = 10;
const HEIGHT = 20;

// 每个方块格子的尺寸（单位像素）
const BLOCK_SIZE = 30;

// 获取canvas元素及绘图上下文
const canvas = document.getElementById('tetrisCanvas');
const ctx = canvas.getContext('2d');

// 游戏网格，用于记录每个位置是否有方块
let grid = new Array(HEIGHT).fill(0).map(() => new Array(WIDTH).fill(0));

// 当前下落的方块对象
let currentBlock = {
  shape: null,
  x: 0,
  y: 0,
  color: null,
  rotation: 0
};

// 初始化游戏，设置初始方块等
function initGame() {
  currentBlock.shape = getRandomShape();
  currentBlock.x = Math.floor(WIDTH / 2) - Math.floor(currentBlock.shape.length / 2);
  currentBlock.y = 0;
  currentBlock.color = getColorForShape(currentBlock.shape);
}

// 获取随机的方块形状
function getRandomShape() {
  return SHAPES[Math.floor(Math.random() * SHAPES.length)];
}

// 根据方块形状获取对应的颜色
function getColorForShape(shape) {
  return COLORS[SHAPES.indexOf(shape)];
}

// 绘制单个方块格子
function drawBlock(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  ctx.strokeStyle = "black";
  ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
}

// 绘制游戏网格背景
function drawGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let y = 0; y < HEIGHT; y++) {
    for (let x = 0; x < WIDTH; x++) {
      if (grid[y][x]) {
        drawBlock(x, y, grid[y][x]);
      }
    }
  }
}

// 绘制当前下落的方块
function drawCurrentBlock() {
  const shape = currentBlock.shape;
  const color = currentBlock.color;
  for (let row = 0; row < shape.length; row++) {
    for (let col = 0; col < shape[row].length; col++) {
      if (shape[row][col]) {
        drawBlock(currentBlock.x + col, currentBlock.y + row, color);
      }
    }
  }
}

// 检测方块是否与游戏区域边界或已有方块碰撞
function checkCollision(block) {
  const shape = block.shape;
  for (let row = 0; row < shape.length; row++) {
    for (let col = 0; col < shape[row].length; col++) {
      if (shape[row][col]) {
        const x = block.x + col;
        const y = block.y + row;
        if (x < 0 || x >= WIDTH || y >= HEIGHT || (y >= 0 && grid[y][x])) {
          return true;
        }
      }
    }
  }
  return false;
}

// 旋转方块
function rotateBlock() {
  const rotatedShape = rotateMatrix(currentBlock.shape);
  const rotatedBlock = {
   ...currentBlock,
    shape: rotatedShape,
    rotation: (currentBlock.rotation + 1) % 4
  };
  if (!checkCollision(rotatedBlock)) {
    currentBlock = rotatedBlock;
  }
}

// 旋转矩阵（用于方块旋转的逻辑计算）
function rotateMatrix(matrix) {
  return matrix[0].map((_, index) => matrix.map(row => row[index]).reverse());
}

// 移动方块（左右移动和下落）
function moveBlock(dx, dy) {
  const newBlock = {
   ...currentBlock,
    x: currentBlock.x + dx,
    y: currentBlock.y + dy
  };
  if (!checkCollision(newBlock)) {
    currentBlock = newBlock;
  }
}

// 锁定当前方块到游戏网格
function lockBlock() {
  const shape = currentBlock.shape;
  for (let row = 0; row < shape.length; row++) {
    for (let col = 0; col < shape[row].length; col++) {
      if (shape[row][col]) {
        grid[currentBlock.y + row][currentBlock.x + col] = currentBlock.color;
      }
    }
  }
  clearLines();
  initGame();
  if (checkCollision(currentBlock)) {
    alert("Game Over!");
    grid = new Array(HEIGHT).fill(0).map(() => new Array(WIDTH).fill(0));
    initGame();
  }
}

// 清除满行
function clearLines() {
  for (let y = HEIGHT - 1; y >= 0; y--) {
    let fullRow = true;
    for (let x = 0; x < WIDTH; x++) {
      if (!grid[y][x]) {
        fullRow = false;
        break;
      }
    }
    if (fullRow) {
      for (let moveY = y; moveY > 0; moveY--) {
        grid[moveY] = [...grid[moveY - 1]];
      }
      grid[0] = new Array(WIDTH).fill(0);
    }
  }
}

// 游戏主循环，不断更新和渲染游戏状态
function gameLoop() {
  drawGrid();
  drawCurrentBlock();
  moveBlock(0, 1);
  if (checkCollision(currentBlock)) {
    moveBlock(0, -1);
    lockBlock();
  }
  requestAnimationFrame(gameLoop);
}

// 监听键盘事件来控制方块移动、旋转
function handleKeyDown(event) {
  switch (event.keyCode) {
   


case 37: // 左箭头
      moveBlock(-1, 0);
      break;
    case 39: // 右箭头
      moveBlock(1, 0);
      break;
    case 40: // 下箭头
      moveBlock(0, 1);
      break;
    case 38: // 上箭头
      rotateBlock();
      break;
  }
}

// 初始化游戏并开始游戏循环，绑定键盘事件
window.onload = function () {
  initGame();
  document.addEventListener('keydown', handleKeyDown);
  requestAnimationFrame(gameLoop);
};